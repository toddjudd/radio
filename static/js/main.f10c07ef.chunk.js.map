{"version":3,"sources":["App.js","static/helpers.js","index.js"],"names":["RadioApp","mapActions","createGrid","numRows","numColumns","console","log","rows","r","push","Array","from","el","c","isIsland","calcPath","grid","path","map","cell","possibleStartPos","reduce","accCell","pathAction","i","pathCell","action","type","tmpSonarFirstHit","sonarHits","slice","findIndex","hit","useReducer","state","columns","mapAction","payload","indexOf","length","row","calcedGrid","possibleEndPos","concat","apply","filter","endCell","radioState","raidoDispatch","useEffect","className","onSubmit","e","prevenDefault","htmlFor","name","value","onChange","parseInt","target","onClick","split","word","string","charAt","toUpperCase","join","style","gridTemplateColumns","gridTemplateRows","key","island","startPos","endPos","disabled","ReactDOM","render","StrictMode","App","document","getElementById"],"mappings":"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","file":"static/js/main.f10c07ef.chunk.js","sourcesContent":["import React, { useReducer, useEffect } from 'react';\nimport className from 'classnames';\nimport { capitalizeFirstLetter } from './static/helpers';\nconst RadioApp = () => {\n  const gridsize = 10;\n  const mapActions = ['island', 'sonar-hit', 'sonar-miss'];\n  const radioReducer = (state, action) => {\n    switch (action.type) {\n      case 'init':\n        return {\n          rows: gridsize,\n          columns: gridsize,\n          grid: createGrid(gridsize, gridsize),\n          mapAction: 'island',\n          path: []\n        };\n      case 'grid':\n        console.log('grid');\n        return { ...state, grid: createGrid(state.rows, state.columns) };\n      case 'rows':\n        return { ...state, rows: action.payload };\n      case 'columns':\n        return { ...state, columns: action.payload };\n      case 'toggle-map':\n        return {\n          ...state,\n          mapAction:\n            mapActions[\n              mapActions.indexOf(state.mapAction) + 1 === mapActions.length\n                ? 0\n                : mapActions.indexOf(state.mapAction) + 1\n            ]\n        };\n      case 'island':\n        console.log('island');\n        return {\n          ...state,\n          grid: state.grid.map((row, r) => {\n            return row.map((cell, c) => {\n              if (r === action.payload.r && c === action.payload.c) {\n                return {\n                  ...cell,\n                  isIsland: !cell.isIsland\n                };\n              }\n              return cell;\n            });\n          })\n        };\n      case 'sonar-hit':\n        return {\n          ...state,\n          path: [...state.path, { action: 'sonar', type: 'hit', hit: true, cell: action.payload }]\n        };\n      case 'sonar-miss':\n        return {\n          ...state,\n          path: [...state.path, { action: 'sonar', type: 'miss', hit: false, cell: action.payload }]\n        };\n      case 'move':\n        const calcedGrid = calcPath(\n          state.grid,\n          [...state.path, { action: 'direction', type: action.payload }],\n          state.rows\n        );\n\n        const flatGrid = [].concat.apply([], calcedGrid);\n\n        // console.log(flatGrid);\n\n        const possibleEndPos = flatGrid\n          .filter(cell => cell.possibleStartPos && cell.pathCell)\n          .map(cell => cell.pathCell);\n\n        // console.log(possibleEndPos);\n\n        const grid = calcedGrid.map((rows, r) => {\n          return rows.map((cell, c) => {\n            return {\n              ...cell,\n              possibleEndPos:\n                possibleEndPos.findIndex(endCell => endCell.r === cell.r && endCell.c === cell.c) +\n                1\n                  ? true\n                  : false\n            };\n          });\n        });\n\n        return {\n          ...state,\n          path: [...state.path, { action: 'direction', type: action.payload }],\n          grid\n        };\n      case 'silent':\n        console.log('silent');\n        return state;\n      default:\n        return null;\n    }\n  };\n\n  //usecallback?\n  const createGrid = (numRows, numColumns) => {\n    console.log(`createGrid ${numRows} ${numColumns}`);\n    let rows = [];\n    for (let r = 0; r < numRows; r++) {\n      rows.push(\n        Array.from(Array(numColumns), (el, c) => {\n          let cell = {\n            isIsland: false,\n            r,\n            c\n          };\n          return cell;\n        })\n      );\n    }\n    return rows;\n  };\n\n  //usecallback?\n  const calcPath = (grid, path, numRows) => {\n    // console.log('calcPath');\n    // console.log({ grid, path });\n    return grid.map((rows, r) => {\n      // console.log('rows');\n      // console.log({ rows, r });\n      return rows.map((cell, c) => {\n        // console.log('cell');\n        // console.log({ cell, c });\n        if (cell.isIsland) {\n          return {\n            ...cell,\n            possibleStartPos: false\n          };\n        }\n        if (typeof cell.possibleStartPos === 'undefined' || cell.possibleStartPos) {\n          // console.log(`cell ${cell.r}-${cell.c} is Possible Starting Pos: start Reduce.`);\n          return path.reduce((accCell, pathAction, i, path) => {\n            // console.log('reducing');\n            if (i === 0) {\n              console.log('initial reduce - Nulling pathCell');\n              accCell.pathCell = null;\n            }\n            if (typeof accCell.possibleStartPos !== 'undefined' && !accCell.possibleStartPos) {\n              return accCell;\n            }\n            // console.log('pathAction');\n            // console.log(pathAction);\n            switch (pathAction.action) {\n              case 'sonar':\n                // console.log('sonar');\n                switch (pathAction.type) {\n                  case 'hit':\n                    // console.log('hit');\n                    //if first\n                    if (i === 0 || path[i - 1].type !== 'hit') {\n                      // console.log('isFirstHit');\n                      //set first on accCell\n                      accCell.tmpSonarFirstHit = i;\n                      // console.log(accCell.tmpSonarFirstHit);\n                      //keep going in logic in even only one sonar hit in list\n                    }\n                    //if last\n                    if (path[i + 1].type !== 'hit') {\n                      // console.log('isLastHit');\n                      //grab copy of path array... split to only the bits we need\n                      const sonarHits = [...path].slice(accCell.tmpSonarFirstHit, i + 1);\n                      // console.log(sonarHits);\n                      // if path node is not in copy of array of hit mark nodes. set as not starting loc and move on\n                      if (accCell.pathCell) {\n                        // console.log('path cell exists');\n                        // console.log(accCell.pathCell);\n                        if (\n                          !(\n                            sonarHits.findIndex(\n                              hit =>\n                                accCell.pathCell.r === hit.cell.r &&\n                                accCell.pathCell.c === hit.cell.c\n                            ) + 1\n                          )\n                        ) {\n                          // console.log('path node is not in sonar hits');\n                          return { ...accCell, possibleStartPos: false };\n                          // returning this here I beleive this is killing the path cell tree\n                        }\n                      } else {\n                        // console.log(\"path cell doesn't exist\");\n                        // console.log(accCell);\n                        // console.log(\n                        //   !(\n                        //     sonarHits.findIndex(hit => {\n                        //       return accCell.r === hit.cell.r && accCell.c === hit.cell.c;\n                        //     }) + 1\n                        //   )\n                        // );\n                        if (\n                          !(\n                            sonarHits.findIndex(hit => {\n                              // console.log('findIndex');\n                              return accCell.r === hit.cell.r && accCell.c === hit.cell.c;\n                            }) + 1\n                          )\n                        ) {\n                          // console.log('AccCell node is not in sonar hits');\n                          return { ...accCell, possibleStartPos: false };\n                          // returning this here I beleive this is killing the path cell tree\n                        }\n                      }\n                    }\n                    // console.log('isMiddleHit');\n\n                    //if not last and not first skip\n                    break;\n\n                  case 'miss':\n                    // if path node is equal to miss mark node as not starting loc and move on\n\n                    // This block appears to work - because it's marking misses and not hit's it can focus on each miss individually\n                    if (accCell.pathCell) {\n                      if (\n                        accCell.pathCell.c === pathAction.cell.c &&\n                        accCell.pathCell.r === pathAction.cell.r\n                      ) {\n                        return { ...accCell, possibleStartPos: false };\n                      }\n                    } else {\n                      if (accCell.c === pathAction.cell.c && accCell.r === pathAction.cell.r) {\n                        return { ...accCell, possibleStartPos: false };\n                      }\n                    }\n                    break;\n\n                  default:\n                    break;\n                }\n                return accCell;\n              case 'direction':\n                // console.log('accCell.possibleStartPos is not undefined, and is true');\n                // console.log(`Direction Switch: ${i}. ${direction}`);\n                switch (pathAction.type) {\n                  case 'north':\n                    // console.log('checking North Direction');\n                    if (accCell.pathCell) {\n                      // console.log('PathCell Exists');\n                      if (accCell.pathCell.r - 1 < 0) {\n                        // console.log('moving North on Path Cell foces out of range');\n                        // console.log('returning accCell as is with False Possible Start');\n                        return { ...accCell, possibleStartPos: false };\n                      }\n                      // console.log('setting Path cell to one Cell North');\n                      accCell.pathCell = grid[accCell.pathCell.r - 1][accCell.pathCell.c];\n                    } else {\n                      if (accCell.r - 1 < 0) {\n                        // console.log('moving North on Path Cell foces out of range');\n                        // console.log('returning accCell as is with False Possible Start');\n                        return { ...accCell, possibleStartPos: false };\n                      }\n                      // console.log('setting Path cell to one Cell North');\n                      accCell.pathCell = grid[accCell.r - 1][accCell.c];\n                    }\n                    break;\n                  case 'south':\n                    // console.log('checking South Direction');\n                    if (accCell.pathCell) {\n                      // console.log('PathCell Exists');\n                      if (accCell.pathCell.r + 1 >= numRows) {\n                        // console.log('moving South on Path Cell foces out of range');\n                        // console.log('returning accCell as is with False Possible Start');\n                        return { ...accCell, possibleStartPos: false };\n                      }\n                      // console.log('setting Path cell to one Cell South');\n                      accCell.pathCell = grid[accCell.pathCell.r + 1][accCell.pathCell.c];\n                    } else {\n                      if (accCell.r + 1 >= numRows) {\n                        // console.log('moving South on Path Cell foces out of range');\n                        // console.log('returning accCell as is with False Possible Start');\n                        return { ...accCell, possibleStartPos: false };\n                      }\n                      // console.log('setting Path cell to one Cell South');\n                      accCell.pathCell = grid[accCell.r + 1][accCell.c];\n                    }\n                    break;\n                  case 'east':\n                    if (accCell.pathCell) {\n                      accCell.pathCell = grid[accCell.pathCell.r][accCell.pathCell.c + 1];\n                    } else {\n                      accCell.pathCell = grid[accCell.r][accCell.c + 1];\n                    }\n                    break;\n                  case 'west':\n                    if (accCell.pathCell) {\n                      accCell.pathCell = grid[accCell.pathCell.r][accCell.pathCell.c - 1];\n                    } else {\n                      accCell.pathCell = grid[accCell.r][accCell.c - 1];\n                    }\n                    break;\n                  default:\n                    // return accCell;\n                    break;\n                }\n                break;\n              default:\n                break;\n            }\n            // console.log('current status of acc and path Cells after Direction:');\n            // console.log(accCell);\n            if (typeof accCell.pathCell === 'undefined' || accCell.pathCell.isIsland) {\n              // console.log(\n              // \"pathCell is undefined or is an Island. We're off map and no loger a possibleStartPos\"\n              // );\n              return { ...accCell, possibleStartPos: false };\n            }\n            // console.log('returning Acc with appended path Cell and moving on.');\n            return { ...accCell, possibleStartPos: true };\n          }, cell);\n        }\n        return cell;\n      });\n    });\n  };\n\n  const [radioState, raidoDispatch] = useReducer(radioReducer, {\n    rows: gridsize,\n    columns: gridsize,\n    grid: createGrid(gridsize, gridsize),\n    path: []\n  });\n\n  useEffect(() => {\n    raidoDispatch({ type: 'init' });\n  }, []);\n\n  useEffect(() => {\n    raidoDispatch({ type: 'grid' });\n  }, [radioState.rows, radioState.columns]);\n\n  // useEffect(() => {\n  //   raidoDispatch({ type: 'cacl' });\n  // }, [radioState.path]);\n\n  return (\n    <div className='RadioApp'>\n      <h1>RadioApp</h1>\n      <form onSubmit={e => e.prevenDefault}>\n        <label htmlFor='rows'>\n          <span className='label-content'>Rows:</span>\n          <input\n            type='number'\n            name='rows'\n            value={radioState.rows}\n            onChange={e => raidoDispatch({ type: 'rows', payload: parseInt(e.target.value) || 1 })}\n          />\n        </label>\n        <label htmlFor='columns'>\n          <span className='label-content'>Columns:</span>\n          <input\n            type='number'\n            name='columns'\n            value={radioState.columns}\n            onChange={e =>\n              raidoDispatch({ type: 'columns', payload: parseInt(e.target.value) || 1 })\n            }\n          />\n        </label>\n        <label htmlFor='none'>\n          <span className='label-content'>Toggle Map Input:</span>\n          <button type='button' onClick={() => raidoDispatch({ type: 'toggle-map' })}>\n            {radioState.mapAction &&\n              radioState.mapAction\n                .split('-')\n                .map(word => capitalizeFirstLetter(word))\n                .join(' ')}\n          </button>\n        </label>\n      </form>\n      <div\n        className='map'\n        style={{\n          gridTemplateColumns: `repeat(${radioState.columns}, min-content)`,\n          gridTemplateRows: `repeat(${radioState.rows}, min-content)`\n        }}>\n        {radioState.grid.map((rows, r) =>\n          rows.map((cell, c) => (\n            <div\n              key={`${r}-${c}`}\n              className={className({\n                cell: true,\n                island: cell.isIsland,\n                startPos: cell.possibleStartPos,\n                endPos: cell.possibleEndPos\n              })}\n              // onMouseOver={() => console.log(`Hovering Cell ${r}-${c}`)}\n              onClick={() => {\n                console.log('click');\n                raidoDispatch({ type: radioState.mapAction, payload: { r, c } });\n              }}>\n              <i className='fas fa-ship'></i>\n            </div>\n          ))\n        )}\n      </div>\n      <div className='compass'>\n        <button\n          className='north'\n          onClick={() => raidoDispatch({ type: 'move', payload: 'north' })}\n          type='button'>\n          {/* North */}\n          <i className='fas fa-arrow-up'></i>\n        </button>\n        <button\n          className='east'\n          onClick={() => raidoDispatch({ type: 'move', payload: 'east' })}\n          type='button'>\n          {/* East */}\n          <i className='fas fa-arrow-right'></i>\n        </button>\n        <button\n          className='south'\n          onClick={() => raidoDispatch({ type: 'move', payload: 'south' })}\n          type='button'>\n          {/* South */}\n          <i className='fas fa-arrow-down'></i>\n        </button>\n        <button\n          className='west'\n          onClick={() => raidoDispatch({ type: 'move', payload: 'west' })}\n          type='button'>\n          <i className='fas fa-arrow-left'></i>\n          {/* West */}\n        </button>\n        <button\n          className='surface'\n          onClick={() => raidoDispatch({ type: 'move', payload: 'surface' })}\n          type='button'>\n          Surface\n        </button>\n        <button\n          className='silent'\n          onClick={() => raidoDispatch({ type: 'silent' })}\n          type='button'\n          disabled>\n          Silent\n        </button>\n      </div>\n      <div className='log'>\n        {radioState.path.map((pathAction, i) => (\n          <div className='log-entry' key={i}>\n            <span className='action'>{pathAction.action} </span>\n            <span className='type'>{pathAction.type} </span>\n            {pathAction.cell ? (\n              <span className='sonar-cell'>\n                {pathAction.cell.r}-{pathAction.cell.c}\n              </span>\n            ) : null}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n};\nexport default RadioApp;\n","// import React from 'react';\r\n\r\nexport function formatPrice(cents) {\r\n  return (cents / 100).toLocaleString('en-US', {\r\n    style: 'currency',\r\n    currency: 'USD'\r\n  });\r\n}\r\n\r\nexport function capitalizeFirstLetter(string) {\r\n  if (typeof string !== 'string') return string;\r\n  return string.charAt(0).toUpperCase() + string.slice(1);\r\n}\r\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './static/css/index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}